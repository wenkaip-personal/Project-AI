import numpy as np
np.random.seed(100)

def twoexp(time, t0, amp, rise, skew):
    """
    Calculate a double-sided exponential at 
    all time steps `t` for the given parameters.
    
    The double-sided exponential consists of a 
    positive exponential $amp exp((time-t0)/rise)$ for 
    times $time <= t0$, and a negative exponential 
    $amp exp(-(time-t0)/(s*rise)$ for times $ttime > t0$.
    
    Parameters
    ----------
    time : numpy.ndarray
        The array of time stamps for which to compute 
        the model
    
    t0 : float, $\[t[0], t[-1]\]$
        The peak time of the double-sided exponential
        
    amp : float, $\[0, \infty\]$
        The amplitude of the double-sided exponential
        
    rise : float, $\[0, \infty\]$
        The rise time of the positive exponential at 
        $t <= t0$
        
    skew : float $\[0, \infty\]$
        The skewness of the two-sided exponential. For 
        $s > 1$, the fall time will be longer than the 
        rise time. For $s < 1$, the fall time will be 
        shorter than the rise time.
        
    Returns
    -------
    ym : numpy.ndarray
        An array of the same size of $t$, returning the 
        model flux for each time step
    """
    
    tdiff = (time-t0) / rise
    
    ym = np.zeros_like(time)
    ym[time <= t0] = amp * np.exp(tdiff[time <= t0])
    ym[time > t0] = amp * np.exp(-tdiff[time > t0]/skew)
    
    return ym


def combined_twoexp(time, t0, amp, rise, skew, ybkg=0.0):
    """
    This function takes an arbitrary number of components 
    generated by the `two_exp` function and linearly sums them 
    all together. 
    
    `t0`, `amp`, `rise`, `skew` are now arrays of the same 
    length $K$ holding the parameter values for each of the 
    $K$ model components being summed.
    
    Parameters
    ----------
    time : numpy.ndarray
        The array of time stamps for which to compute 
        the model

    t0, amp, rise, skew, ybkg: numpy.ndarray 
        Arrays of the same length $K$ containing 
        the parameters for the `twoexp` function 
        for $K$ components.
        
    ybkg : float, default 0.0
        The constant background flux added to the 
        sum of model components.
        
    Returns
    -------
    ym : numpy.ndarray
        An array of the same size of $t$, returning the 
        model flux for each time step
    """
    ncomp = len(t0)
    
    ym = np.zeros_like(time)
    
    for k in range(ncomp):
        ym += twoexp(time, t0[k], amp[k], rise[k], skew[k])
        
    ym += ybkg
    
    return ym


def simulate_burst(time, ncomp, burstparams, ybkg, return_model=False, noise_type='poisson'):
    """
    Simulate a realistic burst using a linear combination 
    of `twoexp` function components, a background 
    count rate and noise.
    
    The array `burstparams` contains the parameters for 
    each call of the `twoexp` function. It is a flat 
    array that containts first `ncomp` parameters for `t0`,
    then `ncomp` parameters for the amplitude `amp`, then 
    `ncomp` parameters for the rise time `rise`, and finally
    `ncomp` parameters for the skewness `skew.
    
    Parameters
    ----------
    time : numpy.ndarray
        The array of time stamps for which to compute 
        the model
        
    ncomp : int
        The number of `twoexp` components to include 
        in the sum

    burstparams : iterable
        An array containing the parameters for the 
        `twoexp` model. Flat array of the form
        `[t0_1, ..., t0_K, amp_1, ..., amp_K, 
          rise_1, ..., rise_K, skew_1, ..., skew_k]`
          
    ybkg : float
        The background flux
        
    return_model : bool, default False
        If True, return the model flux (without noise)
        along with the noisy model counts. If False, 
        just contain the noisy counts
        
    noise_type : str, default 'poisson'
        The type of noise to add to the model. Can be
        either 'poisson' or 'gaussian'. If 'gaussian',
        the noise will be drawn from a Gaussian distribution
        with a smaller variance.

    Returns
    -------
    ycounts : numpy.ndarray
        An array of the same size of $t$, returning the 
        model counts with noise    
    """
    if len(burstparams) != 4*ncomp:
        raise ValueError("`burstparams` must contain all burst model parameters!")
        
    t0 = burstparams[:ncomp]
    amp = burstparams[ncomp:(2*ncomp)]
    rise = burstparams[(2*ncomp):(3*ncomp)]
    skew = burstparams[(3*ncomp):]
    
    ym = combined_twoexp(time, t0, amp, rise, skew, ybkg)
    
    if noise_type == 'poisson':
        ycounts = np.random.poisson(ym)
    elif noise_type == 'gaussian':
        noise_std = 0.1 * np.sqrt(ym)  # Adjust the noise standard deviation as needed
        ycounts = ym + np.random.normal(0, noise_std)
    else:
        raise ValueError("Invalid noise type. Choose 'poisson' or 'gaussian'.")
    
    if return_model:
        return ym, ycounts

    else:
        return ycounts